package me.boxcubed.main.Sprites;import com.badlogic.gdx.Application;import com.badlogic.gdx.Gdx;import com.badlogic.gdx.Input;import com.badlogic.gdx.Input.Keys;import com.badlogic.gdx.graphics.Texture;import com.badlogic.gdx.graphics.g2d.*;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;import com.badlogic.gdx.math.Vector2;import com.badlogic.gdx.physics.box2d.*;import com.badlogic.gdx.scenes.scene2d.ui.Touchpad;import com.badlogic.gdx.utils.Disposable;import com.boxcubed.net.NetworkManager;import com.boxcubed.utils.Assets;import com.boxcubed.utils.BoxoUtil;import com.boxcubed.utils.InventorySystem;import me.boxcubed.main.Objects.interfaces.EntityType;import me.boxcubed.main.Objects.interfaces.LivingEntity;import me.boxcubed.main.Objects.interfaces.Movable;import me.boxcubed.main.Sprites.guns.AK47;import me.boxcubed.main.Sprites.guns.Gun;import me.boxcubed.main.Sprites.guns.LaserGun;import me.boxcubed.main.Sprites.guns.Pistol;import me.boxcubed.main.States.GameState;import me.boxcubed.main.TopDown;import java.lang.reflect.Method;public class Player implements LivingEntity, Movable {    private final Texture tex = TopDown.assets.get(Assets.player_IMAGE, Texture.class);    private final ParticleEffect bloodEffect = new ParticleEffect(            TopDown.assets.get(Assets.blood_EFFECT, ParticleEffect.class));    private final ParticleEffect effect = TopDown.assets.get(Assets.flame_EFFECT, ParticleEffect.class);    // Body stuff    public Crosshair crossH;    public NetworkManager connection;    public GlyphLayout name = new GlyphLayout();    // end body stuff    public Vector2 multiPos;    public int state;    public float rotation = 0;    public InventorySystem inventory;    private Sprite sprite;    private float delta;    private BodyDef playerDef;    private Body playerBody;    private Fixture fixture;    private float elapsedTime = 0;    private double health = getMaxHealth();    // This vector is used for multiplayer positioning so location can be added    // when world isn't stepping    private float stamina = getMaxStamina();    private Animation<TextureRegion> animationLeg, rifleAnimation, playerAnimation;    private float legOffX = 15, legOffY = 15;    private float velX = 0, velY = 0;    private boolean shooting = false;    private boolean initsed = false;    private World world;    private Gun gun;    private boolean isDisposed = false;    private boolean keyPressed = false;    private boolean hurt = false;    public Player(World world, int state) {        this.world = world;        this.state = state;        name = new GlyphLayout();    }    @SuppressWarnings("unchecked")    private void init(World world, int state) {        sprite = new Sprite(tex);        this.state = state;        this.world = world;        // animation = TopDown.assets.get(Assets.playerATLAS + ":anim",        // Animation.class);        animationLeg = TopDown.assets.get(Assets.leg_ATLAS + ":anim", Animation.class);        rifleAnimation = TopDown.assets.get(Assets.rifleWalk_ATLAS + ":anim", Animation.class);        playerAnimation = TopDown.assets.get(Assets.player_ATLAS + ":anim", Animation.class);        playerDef = new BodyDef();        playerDef.type = BodyDef.BodyType.DynamicBody;        // Shape        PolygonShape playerShape = new PolygonShape();        playerShape.setAsBox(0.5f, 0.5f);        // Fixture def        FixtureDef fixtureDefPlayer = new FixtureDef();        fixtureDefPlayer.shape = playerShape;        fixtureDefPlayer.friction = 0f;        // Creates the body and assigns vars to all important values        playerBody = world.createBody(playerDef);        fixture = playerBody.createFixture(fixtureDefPlayer);        fixture.setUserData("PLAYER");        playerBody.setTransform(340 / GameState.PPM, 300 / GameState.PPM, 0);        playerShape.dispose();        sprite.setSize(20, 20);        crossH = new Crosshair(this);        legOffY = 10;        legOffX = 11;        // Inventory system        inventory = new InventorySystem();        // adding items here, for now        // will create a method later to add items on events eg. walking over        // gun or heath pack        inventory.addItem(0, new Pistol());        inventory.addItem(1, new AK47());        inventory.addItem(2, new LaserGun());        gun = (Gun) inventory.getItem();        inventory.listItems();        BoxoUtil.addInputProcessor(inventory);        if (state == 1 && connection == null) {            connection = new NetworkManager(this);        }        initsed = true;    }    public void setConnection(NetworkManager connection) {        this.connection = connection;        connection.setPlayer(this);        this.state = 1;    }    @Override    public void update(float delta) {        if (!initsed) {            init(world, state);        }        if (isAlive()) {            if (state == 2 || state == 1) {                if (multiPos != null)                    getBody().setTransform(multiPos, 0);            }            if (delta < 1f)                this.delta = 1f;            else                this.delta = delta;            handleInput();            if (inventory.itemSelected instanceof Gun)                gun = (Gun) inventory.itemSelected;            if (state == 2)                playerBody.setLinearVelocity(0, 0);            if (shooting && state == 0) {                effect.setPosition(getPos(true).x, getPos(true).y);                for (ParticleEmitter emit : effect.getEmitters()) {                    emit.getAngle().setHigh(rotation + 20);                    emit.getAngle().setLow(rotation - 20);                }                effect.setDuration(100);                if (effect.isComplete()) {                    effect.reset();                    effect.start();                }            } else                effect.allowCompletion();            if (hurt) {                bloodEffect.setPosition(getPos(true).x, getPos(true).y);                bloodEffect.update(delta / 100);                if (bloodEffect.isComplete())                    hurt = false;            }            effect.update(delta / 100);            if (keyPressed && !Gdx.app.getType().equals(Application.ApplicationType.Android))                elapsedTime += delta;            crossH.update(delta, rotation);            sprite.setRotation(rotation);        } else {            stop();        }    }    @Override    public void render(SpriteBatch sb) {        // Need some sort of reflection method or something to draw the        // inventory items from here.        if (!initsed)            init(world, state);        if (isAlive()) {            // drawing of effects            effect.draw(sb);            bloodEffect.draw(sb);            sb.draw(animationLeg.getKeyFrame(elapsedTime, true), (playerBody.getPosition().x) * GameState.PPM - 12,                    (playerBody.getPosition().y) * GameState.PPM - 15, legOffX, legOffY, 24, 24, 1, 1, rotation);            if (inventory.itemSelected instanceof AK47) {                sb.draw(rifleAnimation.getKeyFrame(elapsedTime, true), getPos(true).x - 15, getPos(true).y - 15,                        15, 15, 50, 40, 1, 1, rotation);            } else {                sb.draw(playerAnimation.getKeyFrame(elapsedTime, true), getPos(true).x - 15, getPos(true).y - 15,                        15, 15, 43, 40, 1, 1, rotation);            }            if (state == 0)                crossH.render(sb);        } else if (!isDisposed) {            dispose();            isDisposed = true;        }    }    private void handleInput() {        if (state == 2)            return;        if (state == 1) {            processMovment("UNKNOWN");        }        Input input = Gdx.input;        keyPressed = false;        if (stamina < getMaxStamina() && !Gdx.input.isKeyPressed(Keys.SHIFT_LEFT)) {            stamina += delta / 4;        }        if (gun.willFire(input, delta, this)) {            gun.fire(world, this);            if (state == 1)                gun.netFire(connection, world, this);        }        if (state == 1)            return;        if (GameState.instance.touchpad != null) {            Touchpad pad = GameState.instance.touchpad;            velX = pad.getKnobPercentX() * 7f;            velY = pad.getKnobPercentY() * 7f;            elapsedTime += delta * (Math.abs(pad.getKnobPercentX()) + Math.abs(pad.getKnobPercentY())) / 2f;            keyPressed = pad.isTouched();        }        if (input.isKeyPressed(Keys.W) || input.isKeyPressed(Keys.UP)) {            keyPressed = true;            processMovment("UP");        }        if (input.isKeyPressed(Input.Keys.S) || input.isKeyPressed(Keys.DOWN)) {            keyPressed = true;            processMovment("DOWN");        }        if (input.isKeyPressed(Input.Keys.A) || input.isKeyPressed(Keys.LEFT)) {            keyPressed = true;            processMovment("LEFT");        }        if (input.isKeyPressed(Input.Keys.D) || input.isKeyPressed(Keys.RIGHT)) {            keyPressed = true;            processMovment("RIGHT");        }        if (!keyPressed)            stop();        else            getBody().setAngularVelocity(5f);        shooting = input.isKeyPressed(Keys.NUM_0);        getBody().setLinearVelocity(velX, velY);        velX = 0;        velY = 0;    }    private void processMovment(String key) {        stop();        String method;        if (Gdx.input.isKeyPressed(Keys.SHIFT_LEFT)) {            if (stamina > 0) {                stamina -= delta / 4;                elapsedTime += 1;                method = "run";            } else {                method = "go";            }        } else            method = "go";        method += key;        if (key == "UNKNOWN") {            connection.move.w = (byte) (Gdx.input.isKeyPressed(Keys.W) ? 1 : 0);            connection.move.s = (byte) (Gdx.input.isKeyPressed(Keys.S) ? 1 : 0);            connection.move.a = (byte) (Gdx.input.isKeyPressed(Keys.A) ? 1 : 0);            connection.move.d = (byte) (Gdx.input.isKeyPressed(Keys.D) ? 1 : 0);            connection.move.shift = (byte) (Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) ? 1 : 0);            connection.move.space = (byte) (Gdx.input.isKeyPressed(Keys.SPACE) ? 1 : 0);            connection.move.rotation = rotation;            return;        }        if (state == 2 || state == 1)            return;        Method m;        try {            m = getClass().getMethod(method, (Class<?>[]) null);            m.invoke(this, (Object[]) null);            return;        } catch (Exception e) {            e.printStackTrace();        }    }    @Override    public Vector2 getPos(boolean asPixels) {        if (asPixels)            return playerBody.getPosition().cpy().scl(GameState.PPM);        else            return playerBody.getPosition();    }    public void setMultiPos(Vector2 pos) {        multiPos = pos;    }    // Walking    @Override    public Sprite getSprite() {        return sprite;    }    @Override    public void goUP() {        if (!Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) || stamina <= 0) {            velY = 5f;        }    }    @Override    public void goDOWN() {        if (!Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) || stamina <= 0) {            velY = -5f;        }    }    @Override    public void goLEFT() {        if (!Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) || stamina <= 0) {            velX = -5f;        }    }    // Running actions    @Override    public void goRIGHT() {        if (!Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) || stamina <= 0) {            velX = 5f;        }    }// d    @Override    public void runUP() {        velY = 10f;    }    @Override    public void runDOWN() {        velY = -10f;    }    @Override    public void runLEFT() {        velX = -10f;    }    @Override    public void runRIGHT() {        velX = 10f;    }    private void stop() {        playerBody.setLinearVelocity(0f, 0f);        playerBody.setAngularVelocity(0);    }    @Override    public Body getBody() {        return playerBody;    }    @Override    public void dispose() {        world.destroyBody(playerBody);        bloodEffect.dispose();        if (gun instanceof Disposable)            ((Disposable) gun).dispose();        BoxoUtil.remInputProcessor(inventory);    }    @Override    public Fixture getFixture() {        return fixture;    }    @Override    public double getHealth() {        return health;    }    @Override    public void setHealth(double health) {        this.health = health;    }    public float getStamina() {        return stamina;    }    public void setStamina(float stamina) {        this.stamina = stamina;    }    @Override    public double getMaxHealth() {        return 50;    }    public float getMaxStamina() {        return 100;    }    @Override    public void playAnimation(String key) {        if (key.equals("attacked")) {            hurt = true;            bloodEffect.reset();            bloodEffect.start();        }    }    @Override    public EntityType getID() {        return EntityType.PLAYER;    }    @Override    public void renderShapes(ShapeRenderer sr) {    }    @Override    public boolean isAlive() {        return getHealth() > 0;    }    @Override    public boolean isDisposable() {        return isAlive();    }    @Override    public void setDisposable(boolean disposable) {        if (disposable)            setHealth(0);        else setHealth(getMaxHealth());    }}